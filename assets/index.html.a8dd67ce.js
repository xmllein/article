import{_ as c,r as i,o as n,c as p,a as e,b as o,d as l,e as r}from"./app.26c798e2.js";const s="/article/images/2021_uni-app/img/2021-12-23-14-26-23.png",a="/article/images/2021_uni-app/img/2021-12-23-14-43-30.png",d="/article/images/2021_uni-app/img/2021-12-23-14-51-26.png",h="/article/images/2021_uni-app/img/2021-12-23-14-54-43.png",_="/article/images/2021_uni-app/img/2021-12-23-15-00-38.png",m="/article/images/2021_uni-app/img/2021-12-23-15-03-08.png",u="/article/images/2021_uni-app/img/2021-12-23-15-04-54.png",g="/article/images/2021_uni-app/img/2021-12-23-17-31-49.png",b="/article/images/2021_uni-app/img/2021-12-23-21-19-38.png",f="/article/images/2021_uni-app/img/2021-12-23-22-14-05.png",k="/article/images/2021_uni-app/img/2021-12-24-16-35-06.png",x="/article/images/2021_uni-app/img/2021-12-24-19-48-51.png",v="/article/images/2021_uni-app/img/2021-12-24-20-13-35.png",q="/article/images/2021_uni-app/img/2021-12-24-20-40-20.png",j="/article/images/2021_uni-app/img/2021-12-24-20-39-37.png",y="/article/images/2021_uni-app/img/2021-12-24-20-47-14.png",D="/article/images/2021_uni-app/img/2021-12-24-20-52-10.png",w="/article/images/2021_uni-app/img/2021-12-24-20-55-27.png",S="/article/images/2021_uni-app/img/2021-12-24-20-58-53.png",R="/article/images/2021_uni-app/img/2021-12-24-21-13-05.png",I="/article/images/2021_uni-app/img/2021-12-24-22-11-10.png",N="/article/images/2021_uni-app/img/2021-12-24-22-10-48.png",V="/article/images/2021_uni-app/img/2021-12-24-22-45-52.png",B="/article/images/2021_uni-app/img/2021-12-24-23-41-32.png",z="/article/images/2021_uni-app/img/2021-12-25-00-01-29.png",C="/article/images/2021_uni-app/img/2021-12-25-00-21-30.png",T="/article/images/2021_uni-app/img/2021-12-25-00-35-12.png",E="/article/images/2021_uni-app/img/2021-12-25-00-41-10.png",L="/article/images/2021_uni-app/img/2021-12-25-00-50-17.png",P={},O=r('<h1 id="第-7-章-全局状态管理" tabindex="-1"><a class="header-anchor" href="#第-7-章-全局状态管理" aria-hidden="true">#</a> 第 7 章 全局状态管理</h1><h3 id="_1-开篇" tabindex="-1"><a class="header-anchor" href="#_1-开篇" aria-hidden="true">#</a> <mark>1）开篇</mark></h3><p>在上一章中我们完成了 “一半” 的文章搜索功能，并且留下了一些问题。那么这些历史残留的问题，我们将会在本章节中通过 <strong>全局状态管理工具</strong> 进行处理。</p><p>那么究竟什么是 <strong>全局状态管理工具</strong>呢？我们又如何在 <code>uniapp</code> 中使用 全局状态管理工具来解决我们的问题呢？，在完成我们剩下的 文章搜索功能 的时候，我们是否还会再遇到其他的坑呢？</p><p>这些内容我们都会在本章节中为大家一一讲解。</p><h3 id="_2-状态管理-全局状态管理工具" tabindex="-1"><a class="header-anchor" href="#_2-状态管理-全局状态管理工具" aria-hidden="true">#</a> <mark>2）状态管理 - 全局状态管理工具</mark></h3><blockquote><p>老套路，接触一个新知识，还是得先从「为什么要学习它」，然后「针对它提出你的疑问」，最后「带着你的疑问在学习它的时候去解决这些疑问」 -&gt; 终极目的：应用到你的项目中！</p></blockquote><h4 id="_1、场景" tabindex="-1"><a class="header-anchor" href="#_1、场景" aria-hidden="true">#</a> <mark>1、场景</mark></h4><p>在上一章中，我们遇到了一个问题：<strong><code>search-blog</code> 和 <code>search-history</code>、<code>searchData</code> 和 组件</strong> 之间 <strong>强耦合</strong> 。</p><p>如果想要解决这个问题，那么我们需要使用到一个叫做：<strong>全局状态管理工具</strong> 的东西。</p>',10),H=e("code",null,"vue",-1),J=e("code",null,"vue",-1),M={href:"https://vuex.vuejs.org/zh/",target:"_blank",rel:"noopener noreferrer"},X=e("strong",null,"全局状态管理",-1),A=e("code",null,"uniapp",-1),F=e("strong",null,"全局状态管理",-1),G={href:"https://vuex.vuejs.org/zh/",target:"_blank",rel:"noopener noreferrer"},K=e("strong",null,"全局状态管理工具",-1),Q={href:"https://vuex.vuejs.org/zh/",target:"_blank",rel:"noopener noreferrer"},U=r('<h4 id="_2、问题" tabindex="-1"><a class="header-anchor" href="#_2、问题" aria-hidden="true">#</a> <mark>2、问题</mark></h4><blockquote><ol><li>什么是全局状态管理模式 和 什么是全局状态管理工具</li><li>什么是 vuex</li></ol></blockquote><h4 id="_3、知识" tabindex="-1"><a class="header-anchor" href="#_3、知识" aria-hidden="true">#</a> <mark>3、知识</mark></h4><p>明确这两个问题，就开始学习新知识了</p><p><strong>“单向数据流” 理念示意图</strong></p><p><img src="'+s+'" alt="全局状态管理"></p><p>这种图表示的是单向数据流这个模型概念</p><p>啥意思？当我们的应用运用在用户手中的时候 -&gt; 用户所有的操作，这最终操作的东西是什么呢？ -&gt; 用户直接操作的是视图吗？ -&gt; 其实并不是，对于当前的所有用户而言，用户直接操作的内容其实是我们的数据，当我们的数据发生变化的时候，我们的视图是跟随发生变化的，而视图的跟随发生变化会直接反馈到用户他的这一个操作之中 -&gt; 这样一个模型我们就把它称之为是一个单向的数据流模型</p><p>简单来说就是：用户操作 -&gt; 修改数据，数据变化 -&gt; 视图跟随数据发生变化，视图发生变化 -&gt; 反应到用户的眼中来完成用户最初的这个操作</p><ul><li><strong>state</strong>，驱动应用的数据源；</li><li><strong>view</strong>，以声明方式将 <strong>state</strong> 映射到视图；</li><li><strong>actions</strong>，响应在 <strong>view</strong> 上的用户输入导致的状态变化。</li></ul><hr><p>这是我最初的认识误区：</p><p><img src="'+a+'" alt="认识"></p><hr><p>但是，这样一个单向数据流处理其实在某些情况下会非常危险</p><p>比如说：</p><p>当我们的应用遇到**多个组件共享状态（数据）**时，单向数据流的简洁性很容易被破坏（回忆 <code>search-blog</code> 和 <code>search-history</code> 的代码，<code>searchData</code>这个数据在这两个组件里边都有被访问到） -&gt; 破坏的原因是：</p><ul><li>多个视图依赖于同一状态（数据）</li><li>来自不同视图的行为需要变更同一状态（数据）</li></ul><p><img src="'+d+'" alt="数据"></p><p>我们在这两个组件里边分别对这个数据做不同的操作 -&gt; 这种不同行为，影响了同一个数据的变化</p><p>为了解决这个问题</p><p>所以我们不得不通过 <strong>父子组件传递数据</strong> 的方式，来频繁的修改状态（数据）：</p><p><img src="'+h+'" alt="父子通信"></p><p>但是这种方式是 <strong>非常脆弱，通常会导致无法维护的代码。</strong></p><p>说白了就是组件之间的耦合性太强了</p><p>那如何解决呢？ -&gt; 必须使用全局状态管理模式</p><p>💡：什么是全局状态管理模式？</p><p><img src="'+_+'" alt="全局状态管理工具"></p><blockquote><p>全局状态管理模式：<strong>把多个组件之中共用的数据给抽离出来，也就是抽离到一个单独的地方，然后通过一个 单例模式 去进行管理</strong>，而这种管理的方式就叫做【全局状态管理模式】。（关于全局状态的一个管理模式）</p></blockquote><p>而具备 【全局状态管理模式】 的库，我们就把它称之为：【全局状态管理工具】</p><p>而在 <code>vue</code> 中存在一个专门的 【全局状态管理工具】，叫做 <code>vuex</code>。</p><p>因为 <code>uniapp</code> 其实追随了 <code>vue</code> 和 <code>微信小程序</code> 的语法，所以我们可以在 <code>uniapp</code> 中使用 <code>vuex</code> 来进行 【全局状态管理】，并且这是一个 <strong>非常被推荐</strong> 的选择。</p><p>明确了这些概念之后，就来看一下之前我们描述的问题</p><h4 id="_4、答案" tabindex="-1"><a class="header-anchor" href="#_4、答案" aria-hidden="true">#</a> <mark>4、答案</mark></h4><p>问题 1：</p><p><img src="'+m+'" alt="问题 1"></p><p>问题 2：</p><p><img src="'+u+'" alt="问题 2"></p><p>学到了啥？</p><ul><li>全局状态管理工具的概念是啥？</li><li>接触到的新工具：Vuex</li></ul><p>👇：使用 Vuex 管理我们整个项目中的所有共享数据！</p><h3 id="_3-状态管理-在项目中导入-vuex" tabindex="-1"><a class="header-anchor" href="#_3-状态管理-在项目中导入-vuex" aria-hidden="true">#</a> <mark>3）状态管理 - 在项目中导入 vuex</mark></h3><p>使用 vuex 分成两大步：</p><ol><li>创建<code>store</code>模块</li><li>在<code>main.js</code>中注册<code>vuex</code>插件</li></ol><p>实现：</p><ol><li>定位到根目录 -&gt; 创建<code>store/index.js</code> -&gt; 这个文件就是<code>store</code>模块 <ol><li>导入<code>vue</code>和<code>vuex</code></li><li>安装<code>vuex</code>插件</li><li>创建<code>store</code>实例</li></ol></li><li>在<code>main.js</code>的<code>new Vue({})</code>的<code>{}</code>里边挂载<code>store</code>实例</li></ol>',46),W={href:"https://github.com/ppambler/imooc-uni-app/commit/dfbc296",target:"_blank",rel:"noopener noreferrer"},Y=r('<h3 id="_4-状态管理-测试-vuex-是否导入成功" tabindex="-1"><a class="header-anchor" href="#_4-状态管理-测试-vuex-是否导入成功" aria-hidden="true">#</a> <mark>4）状态管理 - 测试 vuex 是否导入成功</mark></h3><p>测试 vuex 是否可以正常使用，测试的方式一共分成了三步：</p><ol><li>创建一个单独的模块：<code>modules/search.js</code> -&gt; 用来表示当前 vuex 中的模块</li><li>在 <code>index.js</code> 中注入（或者说绑定）这个模块</li><li>在 <code>search-blog</code> 中使用 模块中的数据 -&gt; 看一下我们模块里边的数据是否可以被正常访问 -&gt; 可以被正常访问，意味着我们当前的 vuex 已经导入成功了</li></ol><p><img src="'+g+'" alt="全局数据"></p>',4),Z={href:"https://github.com/ppambler/imooc-uni-app/commit/0534bef",target:"_blank",rel:"noopener noreferrer"},$={href:"https://blog.csdn.net/fuck487/article/details/83411856",target:"_blank",rel:"noopener noreferrer"},ee=r('<p>👇：让<code>searchData</code>这个数据和我们的组件解耦</p><h3 id="_5-状态管理-构建-search-模块" tabindex="-1"><a class="header-anchor" href="#_5-状态管理-构建-search-模块" aria-hidden="true">#</a> <mark>5）状态管理 - 构建 search 模块</mark></h3><p>在这个 <code>vuex</code> 模块里边，我们已经拥有了<code>searchData</code>这个数据，也拥有了三个可以修改它的<code>mutation</code>：</p><ol><li>添加数据</li><li>删除指定数据</li><li>删除所有数据</li></ol>',4),oe={href:"https://github.com/ppambler/imooc-uni-app/commit/191910d",target:"_blank",rel:"noopener noreferrer"},te=e("p",null,[o("明确了"),e("code",null,"search"),o("模块的"),e("code",null,"mutation"),o("后，接下来就是实现关于"),e("code",null,"search"),o("模块的数据管理")],-1),le=e("h3",{id:"_6-状态管理-使用-search-模块完成搜索历史管理",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#_6-状态管理-使用-search-模块完成搜索历史管理","aria-hidden":"true"},"#"),o(),e("mark",null,"6）状态管理 - 使用 search 模块完成搜索历史管理")],-1),re=e("p",null,[e("img",{src:b,alt:"搜索历史管理"})],-1),ce={href:"https://github.com/ppambler/imooc-uni-app/commit/1cf403e",target:"_blank",rel:"noopener noreferrer"},ie=r('<p>至此，我们就已经使用 vuex 来分离了我们的数据<code>searchData</code>和我们的业务组件（<code>search-blog</code>和<code>search-history</code>）</p><p>数据都被 <code>vuex</code> 中的 <code>search</code>模块去管理，而所有的业务逻辑都被我们的组件调用 -&gt; 目前的<code>searchData</code>数据和我们的组件之间已经没有任何关系了 -&gt; 说白了，我们<strong>已经完成了数据和组件业务的一个解耦</strong></p><p>👇：数据持久化</p><h3 id="_7-状态管理-数据持久化" tabindex="-1"><a class="header-anchor" href="#_7-状态管理-数据持久化" aria-hidden="true">#</a> <mark>7）状态管理 - 数据持久化</mark></h3><p>这是搜素历史的最后一个功能</p><p>目前，由于基本已完成数据和组件的分离，所以【数据持久化】不会涉及到组件内的代码，也就是整个「数据持久化」操作在<code>search</code>模块里边就可以完成了</p><p>数据持久化，分成两块部分：</p><ol><li>数据的保存</li><li>数据的读取</li></ol><p>数据保存后再读取出来，这个「持久化」功能就完成了！</p><blockquote><p>保存方式跟 localStorage 没啥区别，都是一个<code>key</code>，一个<code>value</code></p><p><code>localStorage.setItem(&quot;data&quot;, JSON.stringify(data))</code> 和 <code>localStorage.getItem(&quot;data&quot;)</code></p><p><code>uni.setStorage({key: &#39;xxx&#39;, data: [] })</code> （可以保存多种类型的数据，而 localStorage 会把值自动转化为字符串）和 <code>uni.getStorageSync(&#39;xxx&#39;)</code></p></blockquote><p>数据持久化搞定后，不管你怎么重新编译，只要有搜索历史，那么这个搜索历史始终都会存在，当然，除非你把对应的<code>key</code>的本地存储给清空了</p><p><img src="'+f+'" alt="数据持久化"></p>',12),ne={href:"https://github.com/ppambler/imooc-uni-app/commit/6f78321",target:"_blank",rel:"noopener noreferrer"},pe=r('<p>三个模块中已完成两个 -&gt; 最后一个「搜索结果」模块</p><p>👇：处理搜索结果的逻辑展示</p><h3 id="_8-搜索结果-获取搜索结果数据" tabindex="-1"><a class="header-anchor" href="#_8-搜索结果-获取搜索结果数据" aria-hidden="true">#</a> <mark>8）搜索结果 - 获取搜索结果数据</mark></h3><p>分析完成后的效果，得出整个搜索结果所涉及到的业务：</p><ol><li>根据搜索内容获取搜索结果</li><li>搜索结果会分成三种样式进行展示 <ol><li>没有图片的样式</li><li>包含一张图片的样式</li><li>包含三张图片的样式</li></ol></li><li>下拉刷新</li><li>上拉加载更多</li><li>点击「向上按钮」返回到最顶部</li></ol><p>接下来就是实现业务</p><p>💡：根据搜索内容获取搜索结果</p><p>分析接口：</p><ol><li><code>q</code>：第一个参数是要搜索的内容</li><li><code>p</code>：第二个参数是分页 -&gt; 毕竟搜索出来的结果条数有很多</li></ol><p><img src="'+k+'" alt="搜索结果"></p>',10),se={href:"https://github.com/ppambler/imooc-uni-app/commit/d54fd00",target:"_blank",rel:"noopener noreferrer"},ae=r('<p>拿到数据后就可以开始渲染对应的 <code>item</code> 项了！</p><h3 id="_9-搜索结果-渲染搜索结果数据" tabindex="-1"><a class="header-anchor" href="#_9-搜索结果-渲染搜索结果数据" aria-hidden="true">#</a> <mark>9）搜索结果 - 渲染搜索结果数据</mark></h3><p>创建三个组件，应对三种展示情况：</p><ol><li><code>search-result-item-theme-1</code>：无图片样式</li><li><code>search-result-item-theme-2</code>：一张图片样式</li><li><code>search-result-item-theme-3</code>：三张图片样式</li></ol><p>每个<code>item</code>数据根据自己到底有没有图片或者有几张图片，来决定自己选择哪件衣服穿！</p><p>效果：</p><p><img src="'+x+'" alt="效果"></p>',7),de={href:"https://github.com/ppambler/imooc-uni-app/commit/8c88986",target:"_blank",rel:"noopener noreferrer"},he=e("p",null,[o("💡："),e("code",null,"rich-text")],-1),_e=e("p",null,[o("返回结果里边有带标签的数据，所以我们用了"),e("code",null,"nodes"),o("属性")],-1),me=e("hr",null,null,-1),ue=e("p",null,"展示的时间是文章发布的真实时间，而我们想要的是相对于今天的时间",-1),ge=e("h3",{id:"_10-搜索结果-处理相对时间",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#_10-搜索结果-处理相对时间","aria-hidden":"true"},"#"),o(),e("mark",null,"10）搜索结果 - 处理相对时间")],-1),be={href:"https://day.js.org/zh-CN/",target:"_blank",rel:"noopener noreferrer"},fe=e("code",null,"uniapp",-1),ke={href:"https://day.js.org/zh-CN/",target:"_blank",rel:"noopener noreferrer"},xe=e("code",null,"npm",-1),ve=e("code",null,"node",-1),qe={href:"https://nodejs.org/en/",target:"_blank",rel:"noopener noreferrer"},je=e("code",null,"LTS",-1),ye=r("<li>通过 <code>npm init -y</code> 初始化 <code>npm</code> 包管理工具</li><li>通过 <code>npm install dayjs@1.10.4 --save-dev</code> （推荐用这个包的版本）安装，安装完成，项目中会多出 <code>node_modules</code> 文件夹</li><li>打开 <code>filters/index.js</code>，添加有关日期处理的代码</li><li>使用过滤器</li>",4),De=r('<p>实现相对时间的过滤器：</p><p><img src="'+v+'" alt="过滤器"></p><blockquote><p>1、2、3 步是导入，4、5 步是加载，第 6 步是使用<code>dayjs</code>里边方法定义我们的逻辑</p></blockquote><p>前五步是通用操作：</p><p><img src="'+q+'" alt="通用操作"></p><p>我们主要实现过滤器：</p><p><img src="'+j+'" alt="过滤器"></p><blockquote><p><code>val</code>是字符串时间 -&gt; <code>dayjs</code>处理后的标准时间 -&gt; 最后一个时间是<code>to</code>处理后的时间，也就是相对于今天<code>dayjs()</code>的时间，即 10 个月前</p></blockquote><p>效果：</p><p><img src="'+y+'" alt="效果"></p>',10),we={href:"https://github.com/ppambler/imooc-uni-app/commit/b605da5",target:"_blank",rel:"noopener noreferrer"},Se=e("h3",{id:"_11-搜索结果-高亮搜索结果关键字",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#_11-搜索结果-高亮搜索结果关键字","aria-hidden":"true"},"#"),o(),e("mark",null,"11）搜索结果 - 高亮搜索结果关键字")],-1),Re=e("p",null,"分析最终完成的效果，看看哪些关键字需要被高亮？",-1),Ie={href:"https://www.json.cn/",target:"_blank",rel:"noopener noreferrer"},Ne=r('<p><img src="'+D+'" alt="json 分析"></p><p>分析得知：</p><p><img src="'+w+'" alt="高亮"></p><p>在 <code>title</code> 字段下，搜索关键字都通过 <code>em</code> 标签进行了标记，所以所谓的 <strong>搜索关键字高亮</strong> 就是 <strong>对 <code>em</code> 标签添加高亮样式</strong></p><p>怎么做？</p><p>直接在<code>style</code>里边添加一个<code>em</code>标签选择器吗？</p><p>可是：</p><p><img src="'+S+'" alt="em"></p><p>所以，这样写是没有效果的！</p><p>虽然我们无法解析我们的标签，但是在<code>rich-text</code>里边，行内样式是可以被进行解析的</p><p>因此，我们可以在高亮的地方，如标题和简介，然后通过正则表达式来搞一个替换 -&gt; 把所有的<code>em</code>标签替换成包含行内样式的<code>em</code>标签</p><p>说白了，就是需要把请求回来的数据再加工一下 -&gt; 给带<code>em</code>标签的，添加行内样式 -&gt; 颜色+间距</p><p>效果：</p><p><img src="'+R+'" alt="效果"></p>',14),Ve={href:"https://github.com/ppambler/imooc-uni-app/commit/",target:"_blank",rel:"noopener noreferrer"},Be=r('<hr><p>实现这个高亮效果，需要服务器端配合，也就是返回的数据需要有<code>em</code>标签 -&gt; 之后，就是前端对这个<code>em</code>标签进行一个行内样式的解析</p><p>总之，<code>rich-text</code>去解析<code>em</code>标签的时候，并不会把这个<code>em</code>标签变成是真正的<code>em</code>标签，然后渲染到 DOM 树里边去，而是依然通过<code>rich-text</code>去进行解析</p><p>简而言之，我们并不能通过<code>em</code>标签选择器去指定我们的高亮样式！</p><h3 id="_12-搜索结果-介绍并使用-mescroll-uni-组件" tabindex="-1"><a class="header-anchor" href="#_12-搜索结果-介绍并使用-mescroll-uni-组件" aria-hidden="true">#</a> <mark>12）搜索结果 - 介绍并使用 mescroll-uni 组件</mark></h3><p>先分析最终完成效果</p><p>上拉加载和下拉刷新是移动端中非常常见的一个功能 -&gt; 这样一个功能被叫做「<code>pullToRefresh</code>」</p>',7),ze={href:"http://www.mescroll.com/uni.html",target:"_blank",rel:"noopener noreferrer"},Ce=e("code",null,"uni app",-1),Te=e("code",null,"pullToRefresh",-1),Ee=e("code",null,"uniapp",-1),Le=e("strong",null,"下拉刷新、上拉加载的功能",-1),Pe=e("p",null,"我们有两种姿势使用它：",-1),Oe=e("ul",null,[e("li",null,[e("code",null,"npm"),o(" 安装依赖")]),e("li",null,"插件导入 -> 推荐这种")],-1),He={href:"https://ext.dcloud.net.cn/plugin?id=343",target:"_blank",rel:"noopener noreferrer"},Je=e("strong",null,"使用 HBuilderX 导入插件",-1),Me=e("p",null,[e("img",{src:I,alt:"导入插件"})],-1),Xe=e("li",null,[e("p",null,[o("导入成功，"),e("code",null,"uni-modules"),o(" 文件夹下会多出 "),e("code",null,"mescroll-ui"),o(" 文件夹")]),e("p",null,[e("img",{src:N,alt:"导入成功"})])],-1),Ae=e("code",null,"mescroll-uni",-1),Fe=e("strong",null,"微信小程序",-1),Ge={href:"https://developers.weixin.qq.com/miniprogram/dev/reference/api/Page.html#onPullDownRefresh",target:"_blank",rel:"noopener noreferrer"},Ke={href:"https://developers.weixin.qq.com/miniprogram/dev/reference/api/Page.html#onReachBottom",target:"_blank",rel:"noopener noreferrer"},Qe=e("strong",null,"页面",-1),Ue=e("strong",null,"微信小程序组件中没有这两个事件",-1),We=e("code",null,"mescroll-uni",-1),Ye=e("strong",null,"页面",-1),Ze=e("strong",null,"组件",-1),$e=e("strong",null,"不同",-1),eo=e("code",null,"mescroll-uni",-1),oo=r("<li><p>我们是在<code>search-result-list.vue</code>里边使用的，所以我们现在先来看 <code>mescroll-uni</code> 在 <strong>组件</strong> 中的使用</p></li><li><p><code>mescroll-uni</code> 在 <strong>组件</strong> 中使用分为两大块：</p><ol><li>在组件中需要去完成的代码</li><li>组件所在页面中需要去完成的代码</li></ol></li>",2),to=r('<p>💡：在组件中需要去完成的代码</p><ol><li>通过 <code>mescroll-body</code> 包裹列表，指定 <code>ref</code> 为 <code>mescrollRef</code> ，监听<code>@init</code>（表示初始化）、<code>@down</code>（表示下拉）、<code>@up</code>（表示上拉） 事件</li><li>导入对应的 <code>mixins</code></li><li>注册 <code>mixins</code></li><li>实现三个回调方法 <ol><li>首次加载</li><li>下拉刷新的回调</li><li>上拉加载的回调</li></ol></li></ol><p>完成这四步，<code>mescroll-uni</code>在组件的使用就完成了！</p><p>实现这四步</p><p>💡：组件所在页面中需要去完成的代码</p><p>除了要完成<code>mescroll-uni</code>在组件中的代码的以外，还要去完成一下组件所在页面中的一个代码，毕竟<code>mescroll-body</code>需要依赖页面中的下拉刷新和上拉加载这两个回调事件</p><p><code>mescroll</code>在组件所在页面中代码分成了三部分：</p><ol><li>给 <code>mescroll-body</code> 的组件添加：<code>ref=&quot;mescrollItem&quot;</code> （<code>mescrollItem</code>这个值是固定的，不可改，与 <code>mescroll-comp.js</code> 对应）</li><li>导入<code>mescroll-comp.js</code></li><li>注册 <code>mixins</code></li></ol><p>经过了以上几个步骤之后，我们的这个<code>mescroll-uni</code>组件就已经导入到<code>search-result-list.vue</code>中了！</p><p>效果：</p><p><img src="'+V+'" alt="效果"></p>',11),lo={href:"https://github.com/ppambler/imooc-uni-app/commit/82f60bb",target:"_blank",rel:"noopener noreferrer"},ro=r('<p>至此，关于这个<code>mescroll</code>的介绍以及导入就已经完成了，简单来说就是从插件市场中导入组件，然后如果你想要在组件中使用的话，首先你得在组件代码中配置一下，之后还得在使用这个组件的页面中配置一下它！</p><p>👇：实现上拉刷新和下拉加载对应的功能</p><h3 id="_13-搜索结果-实现下拉刷新上拉加载功能" tabindex="-1"><a class="header-anchor" href="#_13-搜索结果-实现下拉刷新上拉加载功能" aria-hidden="true">#</a> <mark>13）搜索结果 - 实现下拉刷新上拉加载功能</mark></h3><p>需求：</p><p><img src="'+B+'" alt="需求"></p><p>通过一个<code>isInit</code>数据来管控 -&gt; 说白了，<code>downCallback</code>、<code>upCallback</code>这两个函数执行了，但是业务逻辑没有执行，直接<code>return</code>了</p><p>注意：</p><ul><li>第一次加载完成，页面的底部一直会有一个上拉加载动画 -&gt; 我们需要取消掉 -&gt; 也就是数据获取完成后提示你要关闭动画</li><li>下拉刷新一直都是加载第一页的数据</li><li>面对不同的行为（下拉刷新、上拉加载），给数据源赋值的策略是不用的</li></ul><p>效果：</p><p><img src="'+z+'" alt="效果"></p>',10),co={href:"https://github.com/ppambler/imooc-uni-app/commit/21af760",target:"_blank",rel:"noopener noreferrer"},io=r('<h3 id="_14-搜索结果-处理空数据场景" tabindex="-1"><a class="header-anchor" href="#_14-搜索结果-处理空数据场景" aria-hidden="true">#</a> <mark>14）搜索结果 - 处理空数据场景</mark></h3><p>目前，对于「搜索结果」，我们已经完成了：</p><ul><li>相对时间</li><li>关键字高亮</li><li>下拉刷新和下拉加载</li></ul><p>这样几个功能</p><p>对这个「搜索结果」，还剩下最后一个功能——处理空数据这种情况</p><p>也就是说，这个搜索关键字没有对应的搜索结果</p><p>我测试了一下最终完成的效果，发现不管我怎么搜索，似乎都会有搜索结果，不过当我搜索「seqing」的时候：</p><p><img src="'+C+'" alt="搜索结果"></p><p>另一种测试：直接<code>this.resultList = []</code>即可</p><p>怎么做？</p><ol><li>创建一个用来处理空数据的组件</li><li>什么时候显示这个组件？ -&gt; 定义一个变量<code>isEmpty</code>来管控这个组件的显示与否</li></ol><p>效果：</p><p><img src="'+T+'" alt="效果"></p>',13),no={href:"https://github.com/ppambler/imooc-uni-app/commit/e00565f",target:"_blank",rel:"noopener noreferrer"},po=r('<h3 id="_15-文章搜索-细节修复" tabindex="-1"><a class="header-anchor" href="#_15-文章搜索-细节修复" aria-hidden="true">#</a> <mark>15）文章搜索 - 细节修复</mark></h3><p>目前，文章搜索的功能几乎已经完成了，只不过还有一些细节我们需要进行额外的处理</p><p>啥细节呢？</p><p>比如：搜索历史数据量限制 <code>store/modules/search.js</code></p><p><img src="'+E+'" alt="搜索历史数据量限制"></p><p>实现：</p><ol><li>添加常量</li><li>只保留前 10 个元素，后边的元素都截掉</li></ol><p>效果：</p><p><img src="'+L+'" alt="效果"></p>',9),so={href:"https://github.com/ppambler/imooc-uni-app/commit/c1fbed6",target:"_blank",rel:"noopener noreferrer"},ao=r('<p>至此，文章搜索的功能就已经全部完成了</p><h3 id="_16-总结" tabindex="-1"><a class="header-anchor" href="#_16-总结" aria-hidden="true">#</a> <mark>16）总结</mark></h3><p>在本章节中我们接触到了一个全新的知识点 <strong>全局状态管理工具 vuex</strong>， 我们利用它解决了 <strong>数据与组件深度耦合</strong> 的问题。</p><p>在正式的企业级项目中（无论是 <code>uniapp</code> 项目还是 <code>前端项目</code>） ，<strong>全局状态管理工具</strong> 都是非常重要的一个内容。</p><p>利用「全局状态管理工具」处理完了 “历史遗留” 问题之后，我们解决了文章搜索的最后一个模块 <strong>搜索结果</strong>，在「搜索结果」里边，我们利用「三个组件」分别应对了三种不同的渲染场景，并且通过 <strong>行内样式</strong> 的形式解决了「关键字高亮」的问题。</p><p>最后，为了处理 <strong>pullToRefresh</strong> 这种场景，我们还接触到了一个新的库 <strong>mescroll-uni</strong>，利用它很好地解决了 <strong>下拉刷新，上拉加载的问题</strong>。</p><p>那么在下一章节，我们则会进入到 <strong>文章详情的功能开发</strong>（展示文章评论、文章内容等），而这等待我们的又将会是什么样的难题呢？</p>',7);function ho(_o,mo){const t=i("ExternalLinkIcon");return n(),p("div",null,[O,e("p",null,[o("学习过 "),H,o(" 的同学应该知道，在 "),J,o(" 中，存在一个 "),e("a",M,[o("vuex"),l(t)]),o(" 的库，这个库的作用就是："),X,o("。")]),e("p",null,[o("而在 "),A,o(" 里，如果我们想要实现 "),F,o("，那么 "),e("a",G,[o("vuex"),l(t)]),o(" 也将是一个非常好的选择。")]),e("p",null,[o("那么下面我们就来看一下，什么是 "),K,o("，以及什么是 "),e("a",Q,[o("vuex"),l(t)])]),U,e("blockquote",null,[e("p",null,[e("a",W,[o("Demo"),l(t)])])]),Y,e("blockquote",null,[e("p",null,[e("a",Z,[o("Demo"),l(t)])])]),e("p",null,[o("➹："),e("a",$,[o("vuex namespaced 的作用以及使用方式"),l(t)])]),ee,e("blockquote",null,[e("p",null,[e("a",oe,[o("Demo"),l(t)])])]),te,le,re,e("blockquote",null,[e("p",null,[e("a",ce,[o("Demo"),l(t)])])]),ie,e("blockquote",null,[e("p",null,[e("a",ne,[o("Demo"),l(t)])])]),pe,e("blockquote",null,[e("p",null,[e("a",se,[o("Demo"),l(t)])])]),ae,e("blockquote",null,[e("p",null,[e("a",de,[o("Demo"),l(t)])])]),he,_e,me,ue,ge,e("p",null,[o("相对时间可以借助 "),e("a",be,[o("dayjs"),l(t)]),o(" （体积小，非常适合用来处理日期和时间） 进行处理。想要在 "),fe,o(" 中使用 "),e("a",ke,[o("dayjs"),l(t)]),o(" ，那么需要导入 "),xe,o(" 工具（以下内指令需要在项目路径的终端下进行）：")]),e("ol",null,[e("li",null,[o("需要在电脑中安装 "),ve,o(" 环境，"),e("a",qe,[o("node 安装地址"),l(t)]),o("，推荐下载 "),je,o(" 版本")]),ye]),De,e("blockquote",null,[e("p",null,[e("a",we,[o("Demo"),l(t)])])]),Se,Re,e("p",null,[o("打开 "),e("a",Ie,[o("https://www.json.cn/"),l(t)]),o("，把服务器返回的数据，扔进去：")]),Ne,e("blockquote",null,[e("p",null,[e("a",Ve,[o("Demo"),l(t)])])]),Be,e("p",null,[e("a",ze,[o("mescroll-uni "),l(t)]),o(" 是一个专门为 "),Ce,o(" 准备的 "),Te,o(" 组件。可以帮助 "),Ee,o(" 实现 "),Le,o("。")]),Pe,Oe,e("ol",null,[e("li",null,[e("p",null,[o("在 "),e("a",He,[o("插件市场"),l(t)]),o(" 点击 "),Je]),Me]),Xe,e("li",null,[e("p",null,[Ae,o(" 的实现借助了 "),Fe,o(" 中的 "),e("a",Ge,[o("onPullDownRefresh"),l(t)]),o(" 和 "),e("a",Ke,[o("onReachBottom"),l(t)]),o(" 这两个 "),Qe,o(" 事件。因为 "),Ue,o("，毕竟它们是页面事件，所以 "),We,o(" 在 "),Ye,o(" 和 "),Ze,o(" 中的使用方式 "),$e,o(" -> 说白了，"),eo,o("分成了两种使用方式，一种在页面中使用，另一种在组件中使用")])]),oo]),to,e("blockquote",null,[e("p",null,[e("a",lo,[o("Demo"),l(t)])])]),ro,e("blockquote",null,[e("p",null,[e("a",co,[o("Demo"),l(t)])])]),io,e("blockquote",null,[e("p",null,[e("a",no,[o("Demo"),l(t)])])]),po,e("blockquote",null,[e("p",null,[e("a",so,[o("Demo"),l(t)])])]),ao])}const go=c(P,[["render",ho],["__file","index.html.vue"]]);export{go as default};
