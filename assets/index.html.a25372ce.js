import{_ as a,r as n,o as t,c as r,a as e,b as l,d as s,e as o}from"./app.26c798e2.js";const d={},c=o(`<h2 id="node-js-基础" tabindex="-1"><a class="header-anchor" href="#node-js-基础" aria-hidden="true">#</a> Node.js 基础</h2><h3 id="node-是什么-可以做什么" tabindex="-1"><a class="header-anchor" href="#node-是什么-可以做什么" aria-hidden="true">#</a> Node 是什么？可以做什么？</h3><ul><li>Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境。</li><li>可以写脚本，中间层，服务端渲染（vue，react） 可以实现前后端分离。</li><li>单线程， 适合 I/O 密集型应用，不适合 CPU 密集型应用。</li><li>实现高性能的 web 服务。</li></ul><h3 id="node-全局对象" tabindex="-1"><a class="header-anchor" href="#node-全局对象" aria-hidden="true">#</a> Node 全局对象</h3><ul><li>global： 全局对象，类似于浏览器中的 window 对象。</li><li>process： 进程对象，可以获取当前进程的信息，如环境变量，命令行参数等。 <ul><li>p<wbr>rocess.env： 环境变量</li><li>process.argv： 命令行参数</li><li>process.nextTick： 事件循环的一部分，用于延迟执行回调函数。</li><li>process.cwd()： 当前工作目录</li><li>process.chdir()： 改变当前工作目录</li><li>process.exit()： 退出进程</li><li>process.kill()： 杀死进程</li><li>process.memoryUsage()： 内存使用情况</li><li>process.uptime()： 进程运行时间</li><li>process.hrtime()： 高精度时间</li><li>process.platform： 操作系统平台</li><li>process.version： Node 版本</li><li>process.versions： Node 依赖包版本</li><li>process.pid： 进程 ID</li><li>process.title： 进程名称</li></ul></li><li>console： 控制台对象，用于向标准输出流（stdout）或标准错误流（stderr）输出字符。</li><li>Buffer： 用于操作二进制数据流。</li><li>module： 用于模块化，每个文件都是一个模块，每个模块都有自己的作用域。</li><li>exports： 用于导出模块。</li><li>require： 用于导入模块。</li><li>__filename： 当前模块的文件名，绝对路径。</li><li>__dirname： 当前模块的目录名，绝对路径。</li><li>setTimeout： 延迟执行回调函数。</li><li>setInterval： 间隔执行回调函数。</li><li>setImmediate： 立即执行回调函数。</li><li>clearImmediate： 清除立即执行的回调函数。</li><li>clearTimeout： 清除延迟执行的回调函数。</li><li>clearInterval： 清除间隔执行的回调函数。</li></ul><h3 id="node-事件循环" tabindex="-1"><a class="header-anchor" href="#node-事件循环" aria-hidden="true">#</a> Node 事件循环</h3><ul><li><p>Node.js 是单线程的，但是它使用的是事件驱动来处理并发，这样有助于我们在多核 cpu 的系统上创建多个子进程，从而提高性能。</p></li><li><p>Node.js 事件循环是 Node.js 实现并发的一种方式，它基于事件驱动模型，用于处理异步操作。</p></li><li><p>Node.js 事件循环由以下几个部分组成：</p><ul><li>V8 引擎： 用于执行 JavaScript 代码。</li><li>libuv： 用于处理 I/O 任务。</li><li>事件循环： 用于调度事件回调函数。</li></ul></li><li><p>Node.js 事件循环的执行顺序如下：</p><ul><li>执行全局代码，初始化执行上下文。</li><li>执行事件循环，执行事件回调函数。</li><li>退出事件循环，执行清理工作。</li></ul></li></ul><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code>
   ┌───────────────────────────┐
┌─<span class="token operator">&gt;</span>│           timers          │
│  └─────────────┬─────────────┘
│  ┌─────────────┴─────────────┐
│  │     pending callbacks     │
│  └─────────────┬─────────────┘
│  ┌─────────────┴─────────────┐
│  │       idle<span class="token punctuation">,</span> <span class="token keyword">prepare</span>       │
│  └─────────────┬─────────────┘      ┌───────────────┐
│  ┌─────────────┴─────────────┐      │   incoming:   │
│  │           poll            │<span class="token operator">&lt;</span>─────┤  connections<span class="token punctuation">,</span> │
│  └─────────────┬─────────────┘      │   <span class="token keyword">data</span><span class="token punctuation">,</span> etc<span class="token punctuation">.</span>  │
│  ┌─────────────┴─────────────┐      └───────────────┘
│  │           <span class="token keyword">check</span>           │
│  └─────────────┬─────────────┘
│  ┌─────────────┴─────────────┐
└──┤      <span class="token keyword">close</span> callbacks      │
   └───────────────────────────┘
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>timers： 定时器阶段，执行 setTimeout 和 setInterval 的回调函数。</li><li>pending callbacks： 系统操作的回调函数。</li><li>idle, prepare： 内部使用。</li><li>poll： 轮询阶段，执行 I/O 回调函数。 <ul><li>如果轮询队列不为空，则取出队列中的回调函数并执行。</li><li>如果轮询队列为空，则等待回调函数被加入轮询队列并立即执行。</li><li>如果轮询队列为空且没有设置定时器，则执行下一步。</li></ul></li><li>check： 执行 setImmediate 的回调函数。</li><li>close callbacks： 执行 close 事件的回调函数。</li></ul><h4 id="setimmediate-对比-settimeout" tabindex="-1"><a class="header-anchor" href="#setimmediate-对比-settimeout" aria-hidden="true">#</a> setImmediate() 对比 setTimeout()</h4><ul><li>setImmediate() 和 setTimeout() 都是用于延迟执行回调函数。</li><li>setImmediate() 的回调函数会在 poll 阶段执行，setTimeout() 的回调函数会在 timers 阶段执行。</li><li>setImmediate() 的回调函数会在 setTimeout() 的回调函数之后执行。</li><li>setImmediate() 的回调函数会在 I/O 回调函数之前执行。</li></ul><h4 id="process-nexttick" tabindex="-1"><a class="header-anchor" href="#process-nexttick" aria-hidden="true">#</a> process.nextTick()</h4><ul><li>process.nextTick() 用于延迟执行回调函数，它会在事件循环的下一次循环中执行。</li><li>process.nextTick() 的回调函数会在任何 I/O 事件之前执行。</li><li>process.nextTick() 的回调函数会在 setTimeout() 和 setImmediate() 之前执行。</li><li>process.nextTick() 的回调函数会在任何异步函数之前执行。</li></ul><h3 id="node-模块" tabindex="-1"><a class="header-anchor" href="#node-模块" aria-hidden="true">#</a> Node 模块</h3><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">let</span> str <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">&#39;./a/a&#39;</span><span class="token punctuation">)</span> <span class="token comment">// 默认会自动添加 .js 后缀 .json .node</span>

<span class="token comment">// - Module._load 加载模块</span>
<span class="token comment">// - Module._resolveFilename 解析绝对路径</span>

<span class="token comment">// 1) 要先将 ./a的文件转化为绝对路径</span>
<span class="token comment">// 2) 读取这个文件, 需要增加一个函数 函数内部需要返回module.exports</span>
<span class="token comment">// 3) 让函数执行</span>
<span class="token comment">// 4) new Module 创建模块 根据文件名来创建  exports  id</span>

<span class="token comment">// module.load 加载模块</span>
<span class="token comment">//  Module._extensions 代表的是一个对象 对象上放着很多处理的方法</span>
<span class="token comment">// exports, require, module, __filename, __dirname</span>

<span class="token comment">// 4) 最终返回的是module.exports</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>commonjs 规范 <ul><li>一个文件就是一个模块</li><li>如果模块想给别人使用 module.exports exports 同一个对象但是最终导出的是 module.exports</li><li>如果想使用这个模块 require (同步读取文件，包一个自执行函数，vm.runInthisContext,传入 export 对象，最终返回的是 exports 对象，所以就可以拿到其他模块的内容)</li></ul></li><li>模块的查找规范 <ul><li>第三方模块 module.paths</li><li>如果文件和文件夹重名 先取文件，文件不能取到，找文件夹 package.json = main = index.js**</li></ul></li></ul><h3 id="node-常用内置模块" tabindex="-1"><a class="header-anchor" href="#node-常用内置模块" aria-hidden="true">#</a> Node 常用内置模块</h3><h4 id="path-模块" tabindex="-1"><a class="header-anchor" href="#path-模块" aria-hidden="true">#</a> path 模块</h4><ul><li>path.basename(path[, ext])： 返回 path 的最后一部分，如果指定了 ext，则会将最后一部分的扩展名去掉。</li><li>path.dirname(path)： 返回 path 的目录名。</li><li>path.extname(path)： 返回 path 的扩展名。</li><li>path.isAbsolute(path)： 判断 path 是否为绝对路径。</li><li>path.join([...paths])： 将所有的 path 拼接起来，并返回拼接后的路径。</li><li>path.normalize(path)： 规范化 path，解析 &#39;..&#39; 和 &#39;.&#39; 片段。</li><li>path.parse(path)： 返回 path 的对象。</li><li>path.relative(from, to)： 返回从 from 到 to 的相对路径。</li><li>path.resolve([...paths])： 将所有的 path 拼接起来，并返回拼接后的绝对路径。</li><li>path.sep： 返回操作系统的路径分隔符。</li><li>path.delimiter： 返回操作系统的环境变量分隔符。</li></ul><h4 id="fs-模块" tabindex="-1"><a class="header-anchor" href="#fs-模块" aria-hidden="true">#</a> fs 模块</h4><ul><li>fs.appendFile(path, data[, options], callback)： 追加文件内容。</li><li>fs.chmod(path, mode, callback)： 修改文件权限。</li><li>fs.chown(path, uid, gid, callback)： 修改文件所有者。</li><li>fs.close(fd, callback)： 关闭文件。</li><li>fs.copyFile(src, dest[, flags], callback)： 复制文件。</li><li>fs.createReadStream(path[, options])： 创建可读流。</li><li>fs.createWriteStream(path[, options])： 创建可写流。</li><li>fs.existsSync(path, callback)： 检查文件是否存在。</li><li>fs.readFileSync(path[, options])： 同步读取文件。</li><li>fs.readFile(path[, options], callback)： 异步读取文件。</li></ul><h4 id="util-模块" tabindex="-1"><a class="header-anchor" href="#util-模块" aria-hidden="true">#</a> util 模块</h4><ul><li>util.inherits(constructor, superConstructor)： 继承。</li><li>util.inspect(object[, options])： 将对象转换为字符串。</li><li>util.promisify(original)： 将异步函数转换为返回 Promise 的函数。</li><li>util.callbackify(original)： 将返回 Promise 的函数转换为异步函数。</li><li>util.format(format[, ...args])： 格式化字符串。</li><li>util.deprecate(fn, message[, code])： 弃用函数。</li><li>util.types： 内置类型。</li><li>util.TextDecoder： 文本解码器。</li></ul><h4 id="event-模块" tabindex="-1"><a class="header-anchor" href="#event-模块" aria-hidden="true">#</a> event 模块</h4><ul><li>eventEmitter.on(eventName, listener)： 添加事件监听器。</li><li>eventEmitter.once(eventName, listener)： 添加一次性事件监听器。</li><li>eventEmitter.off(eventName, listener)： 移除事件监听器。</li><li>eventEmitter.emit(eventName[, ...args])： 触发事件。</li><li>eventEmitter.listenerCount(eventName)： 返回事件监听器的数量。</li><li>eventEmitter.listeners(eventName)： 返回事件监听器的数组。</li><li>eventEmitter.rawListeners(eventName)： 返回事件监听器的数组，包含原始监听器。</li><li>eventEmitter.setMaxListeners(n)： 设置事件监听器的最大数量。</li><li>eventEmitter.getMaxListeners()： 返回事件监听器的最大数量。</li><li>eventEmitter.prependListener(eventName, listener)： 添加事件监听器到监听器数组的开头。</li><li>eventEmitter.prependOnceListener(eventName, listener)： 添加一次性事件监听器到监听器数组的开头。</li><li>eventEmitter.eventNames()： 返回事件名称的数组。</li></ul><h4 id="http-模块" tabindex="-1"><a class="header-anchor" href="#http-模块" aria-hidden="true">#</a> http 模块</h4><ul><li>http.createServer([options][, requestListener])： 创建 HTTP 服务器。</li><li>http.request(options[, callback])： 创建 HTTP 客户端。</li><li>http.get(options[, callback])： 创建 HTTP 客户端。</li><li>http.METHODS： HTTP 方法。</li><li>http.STATUS_CODES： HTTP 状态码。</li><li>http.Agent： HTTP 代理。</li><li>http.globalAgent： 全局 HTTP 代理。</li><li>http.ClientRequest： HTTP 客户端请求。</li><li>http.ServerResponse： HTTP 服务器响应。</li><li>http.IncomingMessage： HTTP 请求消息。</li><li>http.Server： HTTP 服务器。</li><li>http.Client： HTTP 客户端。</li><li>http.ServerTimeoutError： HTTP 服务器超时错误。</li><li>http.ClientTimeoutError： HTTP 客户端超时错误。</li></ul><h2 id="参考资料" tabindex="-1"><a class="header-anchor" href="#参考资料" aria-hidden="true">#</a> 参考资料</h2>`,28),p={href:"https://zhuanlan.zhihu.com/p/462189220",target:"_blank",rel:"noopener noreferrer"},u={href:"https://juejin.cn/post/7073715866130612231",target:"_blank",rel:"noopener noreferrer"},m={href:"https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/",target:"_blank",rel:"noopener noreferrer"};function h(v,b){const i=n("ExternalLinkIcon");return t(),r("div",null,[c,e("ul",null,[e("li",null,[e("a",p,[l("JS 模块规范大盘点：CommonJS, AMD, CMD, UMD 和 ES6 Modules 规范与源码实现"),s(i)])]),e("li",null,[e("a",u,[l("Node.js 事件循环，定时器和 process.nextTick()"),s(i)])]),e("li",null,[e("a",m,[l("宏任务，微任务"),s(i)])])])])}const f=a(d,[["render",h],["__file","index.html.vue"]]);export{f as default};
