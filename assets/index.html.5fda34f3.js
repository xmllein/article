import{_ as i,r as a,o as l,c,a as e,b as o,d as r,e as n}from"./app.26c798e2.js";const p="/article/images/2021_uni-app/img/2021-12-27-19-35-40.png",s="/article/images/2021_uni-app/img/2021-12-27-20-38-44.png",d="/article/images/2021_uni-app/img/2021-12-27-23-12-11.png",m="/article/images/2021_uni-app/img/2021-12-28-16-31-53.png",g="/article/images/2021_uni-app/img/2021-12-28-16-37-56.png",h="/article/images/2021_uni-app/img/2021-12-28-17-14-43.png",_="/article/images/2021_uni-app/img/2021-12-28-17-21-47.png",u="/article/images/2021_uni-app/img/2021-12-28-17-20-27.png",b="/article/images/2021_uni-app/img/2021-12-28-17-23-13.png",k="/article/images/2021_uni-app/img/2021-12-28-18-48-34.png",f="/article/images/2021_uni-app/img/2021-12-28-18-58-27.png",x="/article/images/2021_uni-app/img/2021-12-28-19-02-47.png",q="/article/images/2021_uni-app/img/2021-12-28-20-15-45.png",v="/article/images/2021_uni-app/img/2021-12-28-21-13-36.png",D="/article/images/2021_uni-app/img/2021-12-28-21-40-14.png",y="/article/images/2021_uni-app/img/2021-12-29-00-12-16.png",I="/article/images/2021_uni-app/img/2021-12-29-00-27-54.png",U="/article/images/2021_uni-app/img/2021-12-29-01-44-53.png",V="/article/images/2021_uni-app/img/2021-12-29-01-53-46.png",j={},w=n('<h1 id="第-9-章-用户登录" tabindex="-1"><a class="header-anchor" href="#第-9-章-用户登录" aria-hidden="true">#</a> 第 9 章 用户登录</h1><h3 id="_1-开篇" tabindex="-1"><a class="header-anchor" href="#_1-开篇" aria-hidden="true">#</a> <mark>1）开篇</mark></h3><p>在上一章中，我们说到：如果想要完成：关注、收藏、点赞、评论 这些功能的话，那么需要首先完成 <strong>用户登录</strong> 的功能。</p><p>那么这一章中，我们就来看一下，我们应该如何完成 <strong>用户登录</strong> 的功能实现。</p><p>首先我们先来看一下 <strong>用户登录</strong> 的业务逻辑。</p><p>对于 <strong>用户登录</strong> 来说，主要有两个登录的入口：</p><ol><li>在《我的页面》中 -&gt; 也叫个人中心</li><li>在调用需要登录权限的功能时</li></ol><p><img src="'+p+'" alt="登录入口"></p><p>那么在明确了 <strong>用户登录</strong> 的业务逻辑之后，接下来我们就去实现用户登录的对应功能。</p><h3 id="_2-用户登录-登录页面基本样式" tabindex="-1"><a class="header-anchor" href="#_2-用户登录-登录页面基本样式" aria-hidden="true">#</a> <mark>2）用户登录 - 登录页面基本样式</mark></h3><p>效果：</p><p><img src="'+s+'" alt="效果"></p>',12),P={href:"https://github.com/ppambler/imooc-uni-app/commit/fa93150",target:"_blank",rel:"noopener noreferrer"},L=n('<h3 id="_3-用户登录-封装登录组件" tabindex="-1"><a class="header-anchor" href="#_3-用户登录-封装登录组件" aria-hidden="true">#</a> <mark>3）用户登录 - 封装登录组件</mark></h3><p>在开篇中，我们说到，对于 <strong>登录</strong> 功能来说提供了两个登录的入口。</p><p>那么大家想一下，现在我们已经在 <strong>我的</strong> 这个 <code>tab 页</code> 中实现了 <strong>登录的 <code>UI</code></strong>，难道我还需要在另外一个页面中再去实现一遍吗？</p><p>这个肯定是不需要的，对不对。所以我们希望可以复用<strong>登录的 <code>UI</code></strong>，而复用的方式则可以把 <strong>登录的 <code>UI</code></strong> 封装称为一个 <strong>组件</strong></p><ol><li>创建登录组件 <code>my-login</code></li><li>在<code>my</code>里边使用<code>my-login</code>组件</li></ol><p><strong>在调用需要登录权限的功能时，进入的登录页面</strong> -&gt; 我们先不需要去创建，等到使用的时候，再创建就可以了。</p>',6),N={href:"https://github.com/ppambler/imooc-uni-app/commit/dbf9c6f",target:"_blank",rel:"noopener noreferrer"},S=n('<h3 id="_4-用户登录-明确登录的实现思路" tabindex="-1"><a class="header-anchor" href="#_4-用户登录-明确登录的实现思路" aria-hidden="true">#</a> <mark>4）用户登录 - 明确登录的实现思路</mark></h3><p>在实现登录的具体功能之前，为了避免一些没有开发经验的同学直接看代码一脸懵逼，我们需要先来明确一下登录的实现基本逻辑。</p><p>首先对于登录来说，我们会分为两个不同的端来进行适配实现：</p><ol><li>微信小程序</li><li>非微信小程序（在讲解适配时实现）</li></ol><p>我们这里先只讲解 【微信小程序的实现】，【非微信小程序】的实现将在后面的 <strong>适配环节进行</strong>。</p><p><strong>微信小程序：</strong></p><ol><li>想要实现登录功能，那么我们需要调用登录接口来进行实现，而登录接口所需要的参数，我们可以直接通过 <code>getUserProfile</code> 方法进行获取。</li><li>调用登录接口成功，服务端会返回用户的 <code>token</code>，这个 <code>token</code> 为当前的用户身份令牌。（拥有 token） 则表示用户已经登录了。</li><li>而此处的 <code>token</code>，我们需要在多个组件中进行使用，所以 <code>token</code> 需要被保存到 <code>全局状态管理工具 - vuex</code> 中，同时需要保存的还有通过 <code>getUserProfile</code> 获取到的用户基本信息。</li><li>而当前的用户登录状态，我们希望可以一直保存（PS：不需要每次都进行登录）。所以在登录完成后，我们需要把 <strong><code>token</code> 和 <code>userinfo</code></strong> 保存到 <strong>本地存储中</strong></li><li>最后，为了实现 <strong>数据与组件的分离</strong>，我们需要把与 <strong>与登录相关的逻辑</strong> 都封装在 <code>vuex</code> 中进行。</li></ol><p>这些业务是 <strong>前端用户登录的标准逻辑</strong>，大家在以后的前端登录业务处理中，也可以按照此逻辑进行。</p><p>那么从下一小节开始，我们就按照这个逻辑实现一下对应的代码。</p><h3 id="_5-用户登录-封装-action-调用登录接口" tabindex="-1"><a class="header-anchor" href="#_5-用户登录-封装-action-调用登录接口" aria-hidden="true">#</a> <mark>5）用户登录 - 封装 action 调用登录接口</mark></h3><p>在上一小节中，我们分析了【微信小程序】中进行登录的实现逻辑，那么从这一小节开始，我们就实现对应的功能。</p><p><img src="'+d+'" alt="登录流程"></p><p>实现：</p><ol><li>在<code>api/user.js</code>里边定义<code>login</code>函数，用来发送<code>POST</code>请求，请求地址是<code>&#39;/sys/login&#39;</code>，传递的数据是「用户信息」</li><li>在<code>my-login</code>里边定义<code>getUserInfo</code>方法，用来获取用户信息，这个信息是微信登录的用户信息 -&gt; 把这个用户信息交给在<code>vuex</code>里边定义的<code>login</code>方法，用作登录时的请求参数</li><li>在<code>store/user.js</code>里边定义<code>user</code>模块，在<code>store/index.js</code>里边注册<code>user</code>模块，在<code>my-login</code>里边通过<code>mapActions</code>注册<code>user</code>模块的<code>login</code>方法</li></ol>',14),B={href:"https://github.com/ppambler/imooc-uni-app/commit/d935742",target:"_blank",rel:"noopener noreferrer"},C=n('<h3 id="_6-用户登录-保存用户登录状态" tabindex="-1"><a class="header-anchor" href="#_6-用户登录-保存用户登录状态" aria-hidden="true">#</a> <mark>6）用户登录 - 保存用户登录状态</mark></h3><p>用户的登录状态需要被保存到 <code>vuex</code> 中，同时需要进行 <strong>本地存储</strong>。</p><ul><li>用户信息</li><li>用户<code>token</code></li></ul><p>效果：</p><p><img src="'+m+'" alt="效果"></p>',5),E={href:"https://github.com/ppambler/imooc-uni-app/commit/7e9ba20",target:"_blank",rel:"noopener noreferrer"},z=e("h3",{id:"_7-用户登录-完成已登录的用户视图",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#_7-用户登录-完成已登录的用户视图","aria-hidden":"true"},"#"),o(),e("mark",null,"7）用户登录 - 完成已登录的用户视图")],-1),M=e("p",null,[o("当 "),e("code",null,"token"),o(" 存在时，表示用户已经登录了，此时需要 "),e("strong",null,"展示用户登录完成的视图：")],-1),T=e("p",null,[e("img",{src:g,alt:"已登录"})],-1),A={href:"https://github.com/ppambler/imooc-uni-app/commit/9c7ce0b",target:"_blank",rel:"noopener noreferrer"},F=e("h3",{id:"_8-用户登录-实现退出登录功能",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#_8-用户登录-实现退出登录功能","aria-hidden":"true"},"#"),o(),e("mark",null,"8）用户登录 - 实现退出登录功能")],-1),G=e("p",null,[o("删除"),e("code",null,"token"),o("和用户信息即可 -> 两个地方需要删除，"),e("code",null,"vuex"),o("和本地存储")],-1),H=e("p",null,[e("img",{src:h,alt:"退出登录"})],-1),O={href:"https://github.com/ppambler/imooc-uni-app/commit/5cc2bb8",target:"_blank",rel:"noopener noreferrer"},$=n('<h3 id="_9-用户登录-判断用户登录状态" tabindex="-1"><a class="header-anchor" href="#_9-用户登录-判断用户登录状态" aria-hidden="true">#</a> <mark>9）用户登录 - 判断用户登录状态</mark></h3><p>截止到目前为止， <strong>用户登录</strong> 的功能其实就已经全部构建完毕了。</p><p>接下来我们就需要实现：</p><ul><li>关注用户</li><li>文章点赞</li><li>文章收藏</li><li>文章评论</li></ul><p>这四个对应的功能。</p><p>之前我们说过，想要实现这四个功能， 那么需要有一个前提条件就是：<strong>当前用户已登录。</strong></p><p>所以说，我们就需要在用户使用这四个功能之前，来判断用户的登录状态。</p><p><img src="'+_+'" alt="用户登录状态"></p><p>也就是说，在 <strong>用户登录功能完成之后</strong>，我们其实还不可以立刻着手这四个功能的开发，我们还需要进行一步操作，那就是 <strong>判断用户的登录状态！</strong></p><p>想要判断用户的登录状态，我们依然需要在 <code>vuex</code> 中进行（数据和组件分离）：</p><p><img src="'+u+'" alt="登录状态"></p>',11),J={href:"https://github.com/ppambler/imooc-uni-app/commit/3891588",target:"_blank",rel:"noopener noreferrer"},K=n('<p>如果用户未登录，则引导用户进入登录页面，那么这一步功能如何进行实现呢？</p><p><img src="'+b+'" alt="登录页面"></p><h3 id="_10-用户登录-新建登录页面-处理当前场景" tabindex="-1"><a class="header-anchor" href="#_10-用户登录-新建登录页面-处理当前场景" aria-hidden="true">#</a> <mark>10）用户登录 - 新建登录页面，处理当前场景</mark></h3><p>开篇的时候，我们说过，对于 <strong>登录</strong> 来说，包含有两个入口：</p><ol><li>在 《我的页面》中</li><li>在调用需要登录权限的功能时</li></ol><p>那么此时，就是使用到第二个场景的时候了。</p><ol><li>我们创建一个新页面，叫做 <code>login-page</code>，在这个页面中，导入 <code>my-login</code> 组件</li><li>当 <strong>进行登录判定，用户未登录时，进入 <code>login-page</code> 页面</strong></li><li>在 <strong>关注</strong> 用户时，调用这个<code>isLogin</code> <code>action</code></li></ol><p>注意点：</p><ul><li><code>uni.showModal</code>的返回值 -&gt; 根据你是点击确定还是点击取消，来决定下一步操作</li><li><code>uni.showModal</code>的使用 -&gt; 没有用<code>success</code>方法，而是用了<code>async/await</code>去处理 -&gt; 因为需要返回<code>false</code></li></ul><p>效果：</p><p><img src="'+k+'" alt="效果"></p>',11),Q={href:"https://github.com/ppambler/imooc-uni-app/commit/06cff8c",target:"_blank",rel:"noopener noreferrer"},R=n('<h3 id="_11-用户登录-监听登录成功的状态-返回之前页面" tabindex="-1"><a class="header-anchor" href="#_11-用户登录-监听登录成功的状态-返回之前页面" aria-hidden="true">#</a> <mark>11）用户登录 - 监听登录成功的状态，返回之前页面</mark></h3><p>在上一节，我们已经完成了 <strong>在调用需要登录权限的功能时，进入登录页面</strong> ，但是当我们登录完成之后，我们 <strong>还需要返回之前页面</strong>，因为只有这样才能完成我们的功能闭环，所以在这一小节中，我们就去完成这一块的功能：</p><ol><li><code>my-login</code>：在登录成功后，发送事件</li><li><code>login-page</code>：监听登录成功的事件，并返回上一个页面</li></ol><p>效果：</p><p><img src="'+f+'" alt="效果"></p>',5),W={href:"https://github.com/ppambler/imooc-uni-app/commit/8468fc2",target:"_blank",rel:"noopener noreferrer"},X=n('<h3 id="_12-用户登录-处理登录时无-loading-的-bug" tabindex="-1"><a class="header-anchor" href="#_12-用户登录-处理登录时无-loading-的-bug" aria-hidden="true">#</a> <mark>12）用户登录 - 处理登录时无 loading 的 bug</mark></h3><p><img src="'+x+'" alt="loading bug"></p><h3 id="_13-文章操作-关注用户" tabindex="-1"><a class="header-anchor" href="#_13-文章操作-关注用户" aria-hidden="true">#</a> <mark>13）文章操作 - 关注用户</mark></h3><p>在彻底完成了 <strong>登录</strong> 相关的内容之后，接下来就可以回过头去实现这四个功能了。</p><p>首先我们先去实现 <strong>关注用户</strong> 的功能：</p><ol><li>定义 <code>api</code> 接口</li><li>关注用户接口需要传递 <code>token</code> 请求头，所以我们可以在 <code>request.js</code> 中，传递当前的 <code>token</code></li><li>在 <code>blog-detail</code> 中调用 接口</li></ol><p>效果（这是已登录情况）：</p><p><img src="'+q+'" alt="效果"></p>',8),Y={href:"https://github.com/ppambler/imooc-uni-app/commit/4ef255a",target:"_blank",rel:"noopener noreferrer"},Z=n('<h3 id="_14-文章操作-处理发表评论的-ui" tabindex="-1"><a class="header-anchor" href="#_14-文章操作-处理发表评论的-ui" aria-hidden="true">#</a> <mark>14）文章操作 - 处理发表评论的 UI</mark></h3><ol><li>监听 <code>article-operate</code> 中的 输入框点击事件</li><li>在 <code>blog-detail</code> 中展示弹出层</li><li>在 <code>blog-detail</code> 中使用 <code>article-comment-commit</code> 组件</li></ol><p><img src="'+v+'" alt="效果"></p>',3),ee={href:"https://github.com/ppambler/imooc-uni-app/commit/03562d3",target:"_blank",rel:"noopener noreferrer"},oe=n('<h3 id="_15-文章操作-处理评论框的显示问题" tabindex="-1"><a class="header-anchor" href="#_15-文章操作-处理评论框的显示问题" aria-hidden="true">#</a> <mark>15）文章操作 - 处理评论框的显示问题</mark></h3><p>现在评论框已经可以显示出来了，但是目前 <strong>评论框的显示存在两个问题：</strong></p><ol><li>输入内容之后，关闭评论框，再次展示评论框时，之前输入的内容依然存在</li><li>在真机中，软键盘会遮挡评论框的展示</li></ol><p>那么在本小节中，我们就来处理一下这两个问题：</p><p><strong>1. 输入内容之后，关闭评论框，再次展示评论框时，之前输入的内容依然存在：</strong></p><p><strong>原因：</strong></p><p>当 <code>popup</code> 关闭时，<code>article-comment-commit</code> 组件 并未销毁，依然存在</p><p><strong>解决方案：</strong></p><p>监听 <code>popup</code> 的关闭事件，通过 <code>v-if</code> 控制 <code>article-comment-commit</code> 组件的销毁</p><p><strong>2. 在真机中，软键盘会遮挡评论框的展示</strong></p><p><strong>原因：</strong></p><p>软键盘弹出，占用了底部空间</p><p><strong>解决方案：</strong></p><p>检测软键盘的弹出事件，动态修改 <code>article-comment-commit</code> 组件的位置</p><hr><p>效果：</p><p><img src="'+D+'" alt="效果"></p>',17),te={href:"https://github.com/ppambler/imooc-uni-app/commit/db78b7f",target:"_blank",rel:"noopener noreferrer"},re=n('<h3 id="_16-文章操作-发表评论" tabindex="-1"><a class="header-anchor" href="#_16-文章操作-发表评论" aria-hidden="true">#</a> <mark>16）文章操作 - 发表评论</mark></h3><p>在一切准备就绪之后，最后就可以实现 发表评论 的功能了。</p><ol><li>在 <code>api/user</code> 中，定义发表评论的接口</li><li>在 <code>article-comment-commit</code> 中调用接口，发表评论</li><li>在 <code>blog-detail</code> 中传递 <code>id</code> ，处理评论成功之后的操作</li></ol><p>效果：</p><p><img src="'+y+'" alt="效果"></p><p>发送完就关闭遮罩层！</p>',6),ne={href:"https://github.com/ppambler/imooc-uni-app/commit/a97e37f",target:"_blank",rel:"noopener noreferrer"},ie=n('<p>注意：</p><ul><li>单点登录 -&gt; 有两个项目，完成后的项目，开发中的项目，你不能用一个账号同时登录这两个项目，这是互斥的，不然，<code>token</code>会冲突！</li></ul><h3 id="_17-文章操作-回显评论数据" tabindex="-1"><a class="header-anchor" href="#_17-文章操作-回显评论数据" aria-hidden="true">#</a> <mark>17）文章操作 - 回显评论数据</mark></h3><ol><li><code>article-comment-commit</code> ：评论发布成功，传递评论数据对象</li><li><code>article-comment-list</code>：增加添加评论项的方法</li><li><code>blog-detail</code>：评论成功后，调用添加评论项的方法</li></ol><p>效果：</p><p><img src="'+I+'" alt="效果"></p>',6),ae={href:"https://github.com/ppambler/imooc-uni-app/commit/ae7ca8f",target:"_blank",rel:"noopener noreferrer"},le=n('<p>注意点：</p><ul><li>调用组件实例的方法：<code>this.$refs.mescrollItem.addCommentList(data)</code></li></ul><h3 id="_18-文章操作-关于点赞和收藏的功能实现" tabindex="-1"><a class="header-anchor" href="#_18-文章操作-关于点赞和收藏的功能实现" aria-hidden="true">#</a> <mark>18）文章操作 - 关于点赞和收藏的功能实现 </mark></h3><p>因为 <strong>点赞</strong> 和 <strong>收藏</strong> 的功能实现和 <strong>关注</strong>，几乎一致，所以：</p><p><strong>点赞 和 收藏 的功能作为课下作业让大家进行实现，视频中不在进行讲解。</strong></p><p>实现代码会在 <strong>文档</strong> 和 <strong>最终代码</strong> 中进行体现，供大家进行参考。</p><p>💡：<strong>点赞功能实现代码</strong></p><p>效果：</p><p><img src="'+U+'" alt="效果"></p>',9),ce={href:"https://github.com/ppambler/imooc-uni-app/commit/7e5fe85",target:"_blank",rel:"noopener noreferrer"},pe=e("p",null,[o("如果有"),e("code",null,"null"),o("值的情况，那就不要用"),e("code",null,"required: true"),o("了，不然，控制台会有警告")],-1),se={href:"https://forum.vuejs.org/t/shouldnt-null-be-accepted-as-prop-value-with-any-type/63887/3",target:"_blank",rel:"noopener noreferrer"},de={href:"https://zhuanlan.zhihu.com/p/94215454",target:"_blank",rel:"noopener noreferrer"},me=e("p",null,[o("💡："),e("strong",null,"收藏功能实现代码")],-1),ge=e("p",null,"效果：",-1),he=e("p",null,[e("img",{src:V,alt:"效果"})],-1),_e={href:"https://github.com/ppambler/imooc-uni-app/commit/0351210",target:"_blank",rel:"noopener noreferrer"},ue=n('<h3 id="_19-总结" tabindex="-1"><a class="header-anchor" href="#_19-总结" aria-hidden="true">#</a> <mark>19）总结</mark></h3><p>在这一大章中，我们完成了整个的【用户登录】以及【文章详情】的功能。</p><p>针对于【用户登录】来说，我们使用 <code>vuex</code> 来对 【组件】和【数据】进行了分离。</p><p>所有与【用户登录】相关的数据操作，都被封装到了 <code>vuex</code> 之中，这样做的好处在于：<strong>我们可以在多个组件中对数据进行操作，而不需要担心其影响 单向数据流的简洁性。</strong></p><p>而【文章详情】的剩余功能，我们在视频中完成了【关注】和【发布评论】两个功能，而把【点赞】和【收藏】留做了课下作业。这样做的目的是 <strong>可以让大家有能够独立思考，以及独立完成功能的机会。</strong></p><p>那么到现在为止，我们项目还剩余【热播】模块没有完成，那么从下一章开始，我们就要搞定【热播】模块啦。</p>',6);function be(ke,fe){const t=a("ExternalLinkIcon");return l(),c("div",null,[w,e("blockquote",null,[e("p",null,[e("a",P,[o("Demo"),r(t)])])]),L,e("blockquote",null,[e("p",null,[e("a",N,[o("Demo"),r(t)])])]),S,e("blockquote",null,[e("p",null,[e("a",B,[o("Demo"),r(t)])])]),C,e("blockquote",null,[e("p",null,[e("a",E,[o("Demo"),r(t)])])]),z,M,T,e("blockquote",null,[e("p",null,[e("a",A,[o("Demo"),r(t)])])]),F,G,H,e("blockquote",null,[e("p",null,[e("a",O,[o("Demo"),r(t)])])]),$,e("blockquote",null,[e("p",null,[e("a",J,[o("Demo"),r(t)])])]),K,e("blockquote",null,[e("p",null,[e("a",Q,[o("Demo"),r(t)])])]),R,e("blockquote",null,[e("p",null,[e("a",W,[o("Demo"),r(t)])])]),X,e("blockquote",null,[e("p",null,[e("a",Y,[o("Demo"),r(t)])])]),Z,e("blockquote",null,[e("p",null,[e("a",ee,[o("Demo"),r(t)])])]),oe,e("blockquote",null,[e("p",null,[e("a",te,[o("Demo"),r(t)])])]),re,e("blockquote",null,[e("p",null,[e("a",ne,[o("Demo"),r(t)])])]),ie,e("blockquote",null,[e("p",null,[e("a",ae,[o("Demo"),r(t)])])]),le,e("blockquote",null,[e("p",null,[e("a",ce,[o("Demo"),r(t)])])]),pe,e("p",null,[o("➹："),e("a",se,[o("Shouldn't null be accepted as prop value with any type? - Get Help - Vue Forum"),r(t)])]),e("p",null,[o("➹："),e("a",de,[o("『 Vue 小 Case 』- Vue Prop 中的 null vs undefined - 知乎"),r(t)])]),me,ge,he,e("blockquote",null,[e("p",null,[e("a",_e,[o("Demo"),r(t)])])]),ue])}const qe=i(j,[["render",be],["__file","index.html.vue"]]);export{qe as default};
